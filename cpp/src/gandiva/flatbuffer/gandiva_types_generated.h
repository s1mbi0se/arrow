// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GANDIVATYPES_GANDIVA_TYPES_FBS_H_
#define FLATBUFFERS_GENERATED_GANDIVATYPES_GANDIVA_TYPES_FBS_H_

#include "flatbuffers/flatbuffers.h"

namespace gandiva {
namespace types {
namespace fbs {

struct ExtGandivaType;

struct Field;

struct FieldNode;

struct FunctionNode;

struct IfNode;

struct AndNode;

struct OrNode;

struct NullNode;

struct IntNode;

struct FloatNode;

struct DoubleNode;

struct BooleanNode;

struct LongNode;

struct StringNode;

struct BinaryNode;

struct DecimalNode;

struct TreeNode;

struct ExpressionRoot;

struct ExpressionList;

struct Condition;

struct Schema;

struct GandivaDataTypes;

struct GandivaFunctions;

struct FunctionSignature;

struct InNode;

struct IntConstants;

struct LongConstants;

struct DecimalConstants;

struct FloatConstants;

struct DoubleConstants;

struct StringConstants;

struct BinaryConstants;

enum GandivaType {
  GandivaType_NONE = 0,
  GandivaType_BOOL = 1,
  GandivaType_UINT8 = 2,
  GandivaType_INT8 = 3,
  GandivaType_UINT16 = 4,
  GandivaType_INT16 = 5,
  GandivaType_UINT32 = 6,
  GandivaType_INT32 = 7,
  GandivaType_UINT64 = 8,
  GandivaType_INT64 = 9,
  GandivaType_HALF_FLOAT = 10,
  GandivaType_FLOAT = 11,
  GandivaType_DOUBLE = 12,
  GandivaType_UTF8 = 13,
  GandivaType_BINARY = 14,
  GandivaType_FIXED_SIZE_BINARY = 15,
  GandivaType_DATE32 = 16,
  GandivaType_DATE64 = 17,
  GandivaType_TIMESTAMP = 18,
  GandivaType_TIME32 = 19,
  GandivaType_TIME64 = 20,
  GandivaType_INTERVAL = 21,
  GandivaType_DECIMAL = 22,
  GandivaType_LIST = 23,
  GandivaType_STRUCT = 24,
  GandivaType_UNION = 25,
  GandivaType_DICTIONARY = 26,
  GandivaType_MAP = 27,
  GandivaType_MIN = GandivaType_NONE,
  GandivaType_MAX = GandivaType_MAP
};

inline const GandivaType (&EnumValuesGandivaType())[28] {
  static const GandivaType values[] = {
    GandivaType_NONE,
    GandivaType_BOOL,
    GandivaType_UINT8,
    GandivaType_INT8,
    GandivaType_UINT16,
    GandivaType_INT16,
    GandivaType_UINT32,
    GandivaType_INT32,
    GandivaType_UINT64,
    GandivaType_INT64,
    GandivaType_HALF_FLOAT,
    GandivaType_FLOAT,
    GandivaType_DOUBLE,
    GandivaType_UTF8,
    GandivaType_BINARY,
    GandivaType_FIXED_SIZE_BINARY,
    GandivaType_DATE32,
    GandivaType_DATE64,
    GandivaType_TIMESTAMP,
    GandivaType_TIME32,
    GandivaType_TIME64,
    GandivaType_INTERVAL,
    GandivaType_DECIMAL,
    GandivaType_LIST,
    GandivaType_STRUCT,
    GandivaType_UNION,
    GandivaType_DICTIONARY,
    GandivaType_MAP
  };
  return values;
}

inline const char * const *EnumNamesGandivaType() {
  static const char * const names[] = {
    "NONE",
    "BOOL",
    "UINT8",
    "INT8",
    "UINT16",
    "INT16",
    "UINT32",
    "INT32",
    "UINT64",
    "INT64",
    "HALF_FLOAT",
    "FLOAT",
    "DOUBLE",
    "UTF8",
    "BINARY",
    "FIXED_SIZE_BINARY",
    "DATE32",
    "DATE64",
    "TIMESTAMP",
    "TIME32",
    "TIME64",
    "INTERVAL",
    "DECIMAL",
    "LIST",
    "STRUCT",
    "UNION",
    "DICTIONARY",
    "MAP",
    nullptr
  };
  return names;
}

inline const char *EnumNameGandivaType(GandivaType e) {
  if (e < GandivaType_NONE || e > GandivaType_MAP) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGandivaType()[index];
}

enum DateUnit {
  DateUnit_DAY = 0,
  DateUnit_MILLI = 1,
  DateUnit_MIN = DateUnit_DAY,
  DateUnit_MAX = DateUnit_MILLI
};

inline const DateUnit (&EnumValuesDateUnit())[2] {
  static const DateUnit values[] = {
    DateUnit_DAY,
    DateUnit_MILLI
  };
  return values;
}

inline const char * const *EnumNamesDateUnit() {
  static const char * const names[] = {
    "DAY",
    "MILLI",
    nullptr
  };
  return names;
}

inline const char *EnumNameDateUnit(DateUnit e) {
  if (e < DateUnit_DAY || e > DateUnit_MILLI) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDateUnit()[index];
}

enum TimeUnit {
  TimeUnit_SEC = 0,
  TimeUnit_MILLISEC = 1,
  TimeUnit_MICROSEC = 2,
  TimeUnit_NANOSEC = 3,
  TimeUnit_MIN = TimeUnit_SEC,
  TimeUnit_MAX = TimeUnit_NANOSEC
};

inline const TimeUnit (&EnumValuesTimeUnit())[4] {
  static const TimeUnit values[] = {
    TimeUnit_SEC,
    TimeUnit_MILLISEC,
    TimeUnit_MICROSEC,
    TimeUnit_NANOSEC
  };
  return values;
}

inline const char * const *EnumNamesTimeUnit() {
  static const char * const names[] = {
    "SEC",
    "MILLISEC",
    "MICROSEC",
    "NANOSEC",
    nullptr
  };
  return names;
}

inline const char *EnumNameTimeUnit(TimeUnit e) {
  if (e < TimeUnit_SEC || e > TimeUnit_NANOSEC) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTimeUnit()[index];
}

enum IntervalType {
  IntervalType_YEAR_MONTH = 0,
  IntervalType_DAY_TIME = 1,
  IntervalType_MIN = IntervalType_YEAR_MONTH,
  IntervalType_MAX = IntervalType_DAY_TIME
};

inline const IntervalType (&EnumValuesIntervalType())[2] {
  static const IntervalType values[] = {
    IntervalType_YEAR_MONTH,
    IntervalType_DAY_TIME
  };
  return values;
}

inline const char * const *EnumNamesIntervalType() {
  static const char * const names[] = {
    "YEAR_MONTH",
    "DAY_TIME",
    nullptr
  };
  return names;
}

inline const char *EnumNameIntervalType(IntervalType e) {
  if (e < IntervalType_YEAR_MONTH || e > IntervalType_DAY_TIME) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIntervalType()[index];
}

enum SelectionVectorType {
  SelectionVectorType_SV_NONE = 0,
  SelectionVectorType_SV_INT16 = 1,
  SelectionVectorType_SV_INT32 = 2,
  SelectionVectorType_MIN = SelectionVectorType_SV_NONE,
  SelectionVectorType_MAX = SelectionVectorType_SV_INT32
};

inline const SelectionVectorType (&EnumValuesSelectionVectorType())[3] {
  static const SelectionVectorType values[] = {
    SelectionVectorType_SV_NONE,
    SelectionVectorType_SV_INT16,
    SelectionVectorType_SV_INT32
  };
  return values;
}

inline const char * const *EnumNamesSelectionVectorType() {
  static const char * const names[] = {
    "SV_NONE",
    "SV_INT16",
    "SV_INT32",
    nullptr
  };
  return names;
}

inline const char *EnumNameSelectionVectorType(SelectionVectorType e) {
  if (e < SelectionVectorType_SV_NONE || e > SelectionVectorType_SV_INT32) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSelectionVectorType()[index];
}

struct ExtGandivaType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_WIDTH = 6,
    VT_PRECISION = 8,
    VT_SCALE = 10,
    VT_DATEUNIT = 12,
    VT_TIMEUNIT = 14,
    VT_TIMEZONE = 16,
    VT_INTERVALTYPE = 18
  };
  GandivaType type() const {
    return static_cast<GandivaType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  int32_t scale() const {
    return GetField<int32_t>(VT_SCALE, 0);
  }
  DateUnit dateUnit() const {
    return static_cast<DateUnit>(GetField<int8_t>(VT_DATEUNIT, 0));
  }
  TimeUnit timeUnit() const {
    return static_cast<TimeUnit>(GetField<int8_t>(VT_TIMEUNIT, 0));
  }
  const flatbuffers::String *timeZone() const {
    return GetPointer<const flatbuffers::String *>(VT_TIMEZONE);
  }
  IntervalType intervalType() const {
    return static_cast<IntervalType>(GetField<int8_t>(VT_INTERVALTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_PRECISION) &&
           VerifyField<int32_t>(verifier, VT_SCALE) &&
           VerifyField<int8_t>(verifier, VT_DATEUNIT) &&
           VerifyField<int8_t>(verifier, VT_TIMEUNIT) &&
           VerifyOffset(verifier, VT_TIMEZONE) &&
           verifier.VerifyString(timeZone()) &&
           VerifyField<int8_t>(verifier, VT_INTERVALTYPE) &&
           verifier.EndTable();
  }
};

struct ExtGandivaTypeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(GandivaType type) {
    fbb_.AddElement<int8_t>(ExtGandivaType::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(ExtGandivaType::VT_WIDTH, width, 0);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(ExtGandivaType::VT_PRECISION, precision, 0);
  }
  void add_scale(int32_t scale) {
    fbb_.AddElement<int32_t>(ExtGandivaType::VT_SCALE, scale, 0);
  }
  void add_dateUnit(DateUnit dateUnit) {
    fbb_.AddElement<int8_t>(ExtGandivaType::VT_DATEUNIT, static_cast<int8_t>(dateUnit), 0);
  }
  void add_timeUnit(TimeUnit timeUnit) {
    fbb_.AddElement<int8_t>(ExtGandivaType::VT_TIMEUNIT, static_cast<int8_t>(timeUnit), 0);
  }
  void add_timeZone(flatbuffers::Offset<flatbuffers::String> timeZone) {
    fbb_.AddOffset(ExtGandivaType::VT_TIMEZONE, timeZone);
  }
  void add_intervalType(IntervalType intervalType) {
    fbb_.AddElement<int8_t>(ExtGandivaType::VT_INTERVALTYPE, static_cast<int8_t>(intervalType), 0);
  }
  explicit ExtGandivaTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExtGandivaTypeBuilder &operator=(const ExtGandivaTypeBuilder &);
  flatbuffers::Offset<ExtGandivaType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExtGandivaType>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExtGandivaType> CreateExtGandivaType(
    flatbuffers::FlatBufferBuilder &_fbb,
    GandivaType type = GandivaType_NONE,
    uint32_t width = 0,
    int32_t precision = 0,
    int32_t scale = 0,
    DateUnit dateUnit = DateUnit_DAY,
    TimeUnit timeUnit = TimeUnit_SEC,
    flatbuffers::Offset<flatbuffers::String> timeZone = 0,
    IntervalType intervalType = IntervalType_YEAR_MONTH) {
  ExtGandivaTypeBuilder builder_(_fbb);
  builder_.add_timeZone(timeZone);
  builder_.add_scale(scale);
  builder_.add_precision(precision);
  builder_.add_width(width);
  builder_.add_intervalType(intervalType);
  builder_.add_timeUnit(timeUnit);
  builder_.add_dateUnit(dateUnit);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExtGandivaType> CreateExtGandivaTypeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    GandivaType type = GandivaType_NONE,
    uint32_t width = 0,
    int32_t precision = 0,
    int32_t scale = 0,
    DateUnit dateUnit = DateUnit_DAY,
    TimeUnit timeUnit = TimeUnit_SEC,
    const char *timeZone = nullptr,
    IntervalType intervalType = IntervalType_YEAR_MONTH) {
  auto timeZone__ = timeZone ? _fbb.CreateString(timeZone) : 0;
  return gandiva::types::fbs::CreateExtGandivaType(
      _fbb,
      type,
      width,
      precision,
      scale,
      dateUnit,
      timeUnit,
      timeZone__,
      intervalType);
}

struct Field FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_NULLABLE = 8,
    VT_CHILDREN = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const ExtGandivaType *type() const {
    return GetPointer<const ExtGandivaType *>(VT_TYPE);
  }
  bool nullable() const {
    return GetField<uint8_t>(VT_NULLABLE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Field>> *children() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Field>> *>(VT_CHILDREN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyField<uint8_t>(verifier, VT_NULLABLE) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct FieldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Field::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<ExtGandivaType> type) {
    fbb_.AddOffset(Field::VT_TYPE, type);
  }
  void add_nullable(bool nullable) {
    fbb_.AddElement<uint8_t>(Field::VT_NULLABLE, static_cast<uint8_t>(nullable), 0);
  }
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> children) {
    fbb_.AddOffset(Field::VT_CHILDREN, children);
  }
  explicit FieldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldBuilder &operator=(const FieldBuilder &);
  flatbuffers::Offset<Field> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Field>(end);
    return o;
  }
};

inline flatbuffers::Offset<Field> CreateField(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<ExtGandivaType> type = 0,
    bool nullable = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Field>>> children = 0) {
  FieldBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_nullable(nullable);
  return builder_.Finish();
}

inline flatbuffers::Offset<Field> CreateFieldDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<ExtGandivaType> type = 0,
    bool nullable = false,
    const std::vector<flatbuffers::Offset<Field>> *children = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<flatbuffers::Offset<Field>>(*children) : 0;
  return gandiva::types::fbs::CreateField(
      _fbb,
      name__,
      type,
      nullable,
      children__);
}

struct FieldNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD = 4
  };
  const Field *field() const {
    return GetPointer<const Field *>(VT_FIELD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           verifier.EndTable();
  }
};

struct FieldNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_field(flatbuffers::Offset<Field> field) {
    fbb_.AddOffset(FieldNode::VT_FIELD, field);
  }
  explicit FieldNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FieldNodeBuilder &operator=(const FieldNodeBuilder &);
  flatbuffers::Offset<FieldNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FieldNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<FieldNode> CreateFieldNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Field> field = 0) {
  FieldNodeBuilder builder_(_fbb);
  builder_.add_field(field);
  return builder_.Finish();
}

struct FunctionNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTIONNAME = 4,
    VT_INARGS = 6,
    VT_RETURNTYPE = 8
  };
  const flatbuffers::String *functionName() const {
    return GetPointer<const flatbuffers::String *>(VT_FUNCTIONNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *inArgs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *>(VT_INARGS);
  }
  const ExtGandivaType *returnType() const {
    return GetPointer<const ExtGandivaType *>(VT_RETURNTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FUNCTIONNAME) &&
           verifier.VerifyString(functionName()) &&
           VerifyOffset(verifier, VT_INARGS) &&
           verifier.VerifyVector(inArgs()) &&
           verifier.VerifyVectorOfTables(inArgs()) &&
           VerifyOffset(verifier, VT_RETURNTYPE) &&
           verifier.VerifyTable(returnType()) &&
           verifier.EndTable();
  }
};

struct FunctionNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_functionName(flatbuffers::Offset<flatbuffers::String> functionName) {
    fbb_.AddOffset(FunctionNode::VT_FUNCTIONNAME, functionName);
  }
  void add_inArgs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> inArgs) {
    fbb_.AddOffset(FunctionNode::VT_INARGS, inArgs);
  }
  void add_returnType(flatbuffers::Offset<ExtGandivaType> returnType) {
    fbb_.AddOffset(FunctionNode::VT_RETURNTYPE, returnType);
  }
  explicit FunctionNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionNodeBuilder &operator=(const FunctionNodeBuilder &);
  flatbuffers::Offset<FunctionNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FunctionNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<FunctionNode> CreateFunctionNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> functionName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> inArgs = 0,
    flatbuffers::Offset<ExtGandivaType> returnType = 0) {
  FunctionNodeBuilder builder_(_fbb);
  builder_.add_returnType(returnType);
  builder_.add_inArgs(inArgs);
  builder_.add_functionName(functionName);
  return builder_.Finish();
}

inline flatbuffers::Offset<FunctionNode> CreateFunctionNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *functionName = nullptr,
    const std::vector<flatbuffers::Offset<TreeNode>> *inArgs = nullptr,
    flatbuffers::Offset<ExtGandivaType> returnType = 0) {
  auto functionName__ = functionName ? _fbb.CreateString(functionName) : 0;
  auto inArgs__ = inArgs ? _fbb.CreateVector<flatbuffers::Offset<TreeNode>>(*inArgs) : 0;
  return gandiva::types::fbs::CreateFunctionNode(
      _fbb,
      functionName__,
      inArgs__,
      returnType);
}

struct IfNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND = 4,
    VT_THENNODE = 6,
    VT_ELSENODE = 8,
    VT_RETURNTYPE = 10
  };
  const TreeNode *cond() const {
    return GetPointer<const TreeNode *>(VT_COND);
  }
  const TreeNode *thenNode() const {
    return GetPointer<const TreeNode *>(VT_THENNODE);
  }
  const TreeNode *elseNode() const {
    return GetPointer<const TreeNode *>(VT_ELSENODE);
  }
  const ExtGandivaType *returnType() const {
    return GetPointer<const ExtGandivaType *>(VT_RETURNTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COND) &&
           verifier.VerifyTable(cond()) &&
           VerifyOffset(verifier, VT_THENNODE) &&
           verifier.VerifyTable(thenNode()) &&
           VerifyOffset(verifier, VT_ELSENODE) &&
           verifier.VerifyTable(elseNode()) &&
           VerifyOffset(verifier, VT_RETURNTYPE) &&
           verifier.VerifyTable(returnType()) &&
           verifier.EndTable();
  }
};

struct IfNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cond(flatbuffers::Offset<TreeNode> cond) {
    fbb_.AddOffset(IfNode::VT_COND, cond);
  }
  void add_thenNode(flatbuffers::Offset<TreeNode> thenNode) {
    fbb_.AddOffset(IfNode::VT_THENNODE, thenNode);
  }
  void add_elseNode(flatbuffers::Offset<TreeNode> elseNode) {
    fbb_.AddOffset(IfNode::VT_ELSENODE, elseNode);
  }
  void add_returnType(flatbuffers::Offset<ExtGandivaType> returnType) {
    fbb_.AddOffset(IfNode::VT_RETURNTYPE, returnType);
  }
  explicit IfNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IfNodeBuilder &operator=(const IfNodeBuilder &);
  flatbuffers::Offset<IfNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IfNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<IfNode> CreateIfNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TreeNode> cond = 0,
    flatbuffers::Offset<TreeNode> thenNode = 0,
    flatbuffers::Offset<TreeNode> elseNode = 0,
    flatbuffers::Offset<ExtGandivaType> returnType = 0) {
  IfNodeBuilder builder_(_fbb);
  builder_.add_returnType(returnType);
  builder_.add_elseNode(elseNode);
  builder_.add_thenNode(thenNode);
  builder_.add_cond(cond);
  return builder_.Finish();
}

struct AndNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
};

struct AndNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> args) {
    fbb_.AddOffset(AndNode::VT_ARGS, args);
  }
  explicit AndNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AndNodeBuilder &operator=(const AndNodeBuilder &);
  flatbuffers::Offset<AndNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AndNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<AndNode> CreateAndNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> args = 0) {
  AndNodeBuilder builder_(_fbb);
  builder_.add_args(args);
  return builder_.Finish();
}

inline flatbuffers::Offset<AndNode> CreateAndNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TreeNode>> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVector<flatbuffers::Offset<TreeNode>>(*args) : 0;
  return gandiva::types::fbs::CreateAndNode(
      _fbb,
      args__);
}

struct OrNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TreeNode>> *>(VT_ARGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
};

struct OrNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> args) {
    fbb_.AddOffset(OrNode::VT_ARGS, args);
  }
  explicit OrNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OrNodeBuilder &operator=(const OrNodeBuilder &);
  flatbuffers::Offset<OrNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OrNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OrNode> CreateOrNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TreeNode>>> args = 0) {
  OrNodeBuilder builder_(_fbb);
  builder_.add_args(args);
  return builder_.Finish();
}

inline flatbuffers::Offset<OrNode> CreateOrNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TreeNode>> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVector<flatbuffers::Offset<TreeNode>>(*args) : 0;
  return gandiva::types::fbs::CreateOrNode(
      _fbb,
      args__);
}

struct NullNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  const ExtGandivaType *type() const {
    return GetPointer<const ExtGandivaType *>(VT_TYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           verifier.EndTable();
  }
};

struct NullNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<ExtGandivaType> type) {
    fbb_.AddOffset(NullNode::VT_TYPE, type);
  }
  explicit NullNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NullNodeBuilder &operator=(const NullNodeBuilder &);
  flatbuffers::Offset<NullNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NullNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<NullNode> CreateNullNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<ExtGandivaType> type = 0) {
  NullNodeBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct IntNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct IntNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(IntNode::VT_VALUE, value, 0);
  }
  explicit IntNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntNodeBuilder &operator=(const IntNodeBuilder &);
  flatbuffers::Offset<IntNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntNode> CreateIntNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  IntNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct FloatNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct FloatNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(FloatNode::VT_VALUE, value, 0.0f);
  }
  explicit FloatNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatNodeBuilder &operator=(const FloatNodeBuilder &);
  flatbuffers::Offset<FloatNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatNode> CreateFloatNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  FloatNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct DoubleNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DoubleNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(double value) {
    fbb_.AddElement<double>(DoubleNode::VT_VALUE, value, 0.0);
  }
  explicit DoubleNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleNodeBuilder &operator=(const DoubleNodeBuilder &);
  flatbuffers::Offset<DoubleNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleNode> CreateDoubleNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    double value = 0.0) {
  DoubleNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BooleanNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BooleanNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BooleanNode::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BooleanNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BooleanNodeBuilder &operator=(const BooleanNodeBuilder &);
  flatbuffers::Offset<BooleanNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BooleanNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<BooleanNode> CreateBooleanNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BooleanNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct LongNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int64_t value() const {
    return GetField<int64_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct LongNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(int64_t value) {
    fbb_.AddElement<int64_t>(LongNode::VT_VALUE, value, 0);
  }
  explicit LongNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LongNodeBuilder &operator=(const LongNodeBuilder &);
  flatbuffers::Offset<LongNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LongNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<LongNode> CreateLongNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t value = 0) {
  LongNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct StringNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(StringNode::VT_VALUE, value);
  }
  explicit StringNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringNodeBuilder &operator=(const StringNodeBuilder &);
  flatbuffers::Offset<StringNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringNode> CreateStringNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  StringNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringNode> CreateStringNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return gandiva::types::fbs::CreateStringNode(
      _fbb,
      value__);
}

struct BinaryNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<int8_t> *value() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct BinaryNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<int8_t>> value) {
    fbb_.AddOffset(BinaryNode::VT_VALUE, value);
  }
  explicit BinaryNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryNodeBuilder &operator=(const BinaryNodeBuilder &);
  flatbuffers::Offset<BinaryNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryNode> CreateBinaryNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> value = 0) {
  BinaryNodeBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinaryNode> CreateBinaryNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<int8_t>(*value) : 0;
  return gandiva::types::fbs::CreateBinaryNode(
      _fbb,
      value__);
}

struct DecimalNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_PRECISION = 6,
    VT_SCALE = 8
  };
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  int32_t scale() const {
    return GetField<int32_t>(VT_SCALE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyField<int32_t>(verifier, VT_PRECISION) &&
           VerifyField<int32_t>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct DecimalNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(DecimalNode::VT_VALUE, value);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(DecimalNode::VT_PRECISION, precision, 0);
  }
  void add_scale(int32_t scale) {
    fbb_.AddElement<int32_t>(DecimalNode::VT_SCALE, scale, 0);
  }
  explicit DecimalNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DecimalNodeBuilder &operator=(const DecimalNodeBuilder &);
  flatbuffers::Offset<DecimalNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DecimalNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<DecimalNode> CreateDecimalNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> value = 0,
    int32_t precision = 0,
    int32_t scale = 0) {
  DecimalNodeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_precision(precision);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<DecimalNode> CreateDecimalNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr,
    int32_t precision = 0,
    int32_t scale = 0) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return gandiva::types::fbs::CreateDecimalNode(
      _fbb,
      value__,
      precision,
      scale);
}

struct TreeNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELDNODE = 4,
    VT_FNNODE = 6,
    VT_IFNODE = 8,
    VT_ANDNODE = 10,
    VT_ORNODE = 12,
    VT_NULLNODE = 14,
    VT_INTNODE = 16,
    VT_FLOATNODE = 18,
    VT_LONGNODE = 20,
    VT_BOOLEANNODE = 22,
    VT_DOUBLENODE = 24,
    VT_STRINGNODE = 26,
    VT_BINARYNODE = 28,
    VT_DECIMALNODE = 30,
    VT_INNODE = 32
  };
  const FieldNode *fieldNode() const {
    return GetPointer<const FieldNode *>(VT_FIELDNODE);
  }
  const FunctionNode *fnNode() const {
    return GetPointer<const FunctionNode *>(VT_FNNODE);
  }
  const IfNode *ifNode() const {
    return GetPointer<const IfNode *>(VT_IFNODE);
  }
  const AndNode *andNode() const {
    return GetPointer<const AndNode *>(VT_ANDNODE);
  }
  const OrNode *orNode() const {
    return GetPointer<const OrNode *>(VT_ORNODE);
  }
  const NullNode *nullNode() const {
    return GetPointer<const NullNode *>(VT_NULLNODE);
  }
  const IntNode *intNode() const {
    return GetPointer<const IntNode *>(VT_INTNODE);
  }
  const FloatNode *floatNode() const {
    return GetPointer<const FloatNode *>(VT_FLOATNODE);
  }
  const LongNode *longNode() const {
    return GetPointer<const LongNode *>(VT_LONGNODE);
  }
  const BooleanNode *booleanNode() const {
    return GetPointer<const BooleanNode *>(VT_BOOLEANNODE);
  }
  const DoubleNode *doubleNode() const {
    return GetPointer<const DoubleNode *>(VT_DOUBLENODE);
  }
  const StringNode *stringNode() const {
    return GetPointer<const StringNode *>(VT_STRINGNODE);
  }
  const BinaryNode *binaryNode() const {
    return GetPointer<const BinaryNode *>(VT_BINARYNODE);
  }
  const DecimalNode *decimalNode() const {
    return GetPointer<const DecimalNode *>(VT_DECIMALNODE);
  }
  const InNode *inNode() const {
    return GetPointer<const InNode *>(VT_INNODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELDNODE) &&
           verifier.VerifyTable(fieldNode()) &&
           VerifyOffset(verifier, VT_FNNODE) &&
           verifier.VerifyTable(fnNode()) &&
           VerifyOffset(verifier, VT_IFNODE) &&
           verifier.VerifyTable(ifNode()) &&
           VerifyOffset(verifier, VT_ANDNODE) &&
           verifier.VerifyTable(andNode()) &&
           VerifyOffset(verifier, VT_ORNODE) &&
           verifier.VerifyTable(orNode()) &&
           VerifyOffset(verifier, VT_NULLNODE) &&
           verifier.VerifyTable(nullNode()) &&
           VerifyOffset(verifier, VT_INTNODE) &&
           verifier.VerifyTable(intNode()) &&
           VerifyOffset(verifier, VT_FLOATNODE) &&
           verifier.VerifyTable(floatNode()) &&
           VerifyOffset(verifier, VT_LONGNODE) &&
           verifier.VerifyTable(longNode()) &&
           VerifyOffset(verifier, VT_BOOLEANNODE) &&
           verifier.VerifyTable(booleanNode()) &&
           VerifyOffset(verifier, VT_DOUBLENODE) &&
           verifier.VerifyTable(doubleNode()) &&
           VerifyOffset(verifier, VT_STRINGNODE) &&
           verifier.VerifyTable(stringNode()) &&
           VerifyOffset(verifier, VT_BINARYNODE) &&
           verifier.VerifyTable(binaryNode()) &&
           VerifyOffset(verifier, VT_DECIMALNODE) &&
           verifier.VerifyTable(decimalNode()) &&
           VerifyOffset(verifier, VT_INNODE) &&
           verifier.VerifyTable(inNode()) &&
           verifier.EndTable();
  }
};

struct TreeNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fieldNode(flatbuffers::Offset<FieldNode> fieldNode) {
    fbb_.AddOffset(TreeNode::VT_FIELDNODE, fieldNode);
  }
  void add_fnNode(flatbuffers::Offset<FunctionNode> fnNode) {
    fbb_.AddOffset(TreeNode::VT_FNNODE, fnNode);
  }
  void add_ifNode(flatbuffers::Offset<IfNode> ifNode) {
    fbb_.AddOffset(TreeNode::VT_IFNODE, ifNode);
  }
  void add_andNode(flatbuffers::Offset<AndNode> andNode) {
    fbb_.AddOffset(TreeNode::VT_ANDNODE, andNode);
  }
  void add_orNode(flatbuffers::Offset<OrNode> orNode) {
    fbb_.AddOffset(TreeNode::VT_ORNODE, orNode);
  }
  void add_nullNode(flatbuffers::Offset<NullNode> nullNode) {
    fbb_.AddOffset(TreeNode::VT_NULLNODE, nullNode);
  }
  void add_intNode(flatbuffers::Offset<IntNode> intNode) {
    fbb_.AddOffset(TreeNode::VT_INTNODE, intNode);
  }
  void add_floatNode(flatbuffers::Offset<FloatNode> floatNode) {
    fbb_.AddOffset(TreeNode::VT_FLOATNODE, floatNode);
  }
  void add_longNode(flatbuffers::Offset<LongNode> longNode) {
    fbb_.AddOffset(TreeNode::VT_LONGNODE, longNode);
  }
  void add_booleanNode(flatbuffers::Offset<BooleanNode> booleanNode) {
    fbb_.AddOffset(TreeNode::VT_BOOLEANNODE, booleanNode);
  }
  void add_doubleNode(flatbuffers::Offset<DoubleNode> doubleNode) {
    fbb_.AddOffset(TreeNode::VT_DOUBLENODE, doubleNode);
  }
  void add_stringNode(flatbuffers::Offset<StringNode> stringNode) {
    fbb_.AddOffset(TreeNode::VT_STRINGNODE, stringNode);
  }
  void add_binaryNode(flatbuffers::Offset<BinaryNode> binaryNode) {
    fbb_.AddOffset(TreeNode::VT_BINARYNODE, binaryNode);
  }
  void add_decimalNode(flatbuffers::Offset<DecimalNode> decimalNode) {
    fbb_.AddOffset(TreeNode::VT_DECIMALNODE, decimalNode);
  }
  void add_inNode(flatbuffers::Offset<InNode> inNode) {
    fbb_.AddOffset(TreeNode::VT_INNODE, inNode);
  }
  explicit TreeNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TreeNodeBuilder &operator=(const TreeNodeBuilder &);
  flatbuffers::Offset<TreeNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TreeNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<TreeNode> CreateTreeNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<FieldNode> fieldNode = 0,
    flatbuffers::Offset<FunctionNode> fnNode = 0,
    flatbuffers::Offset<IfNode> ifNode = 0,
    flatbuffers::Offset<AndNode> andNode = 0,
    flatbuffers::Offset<OrNode> orNode = 0,
    flatbuffers::Offset<NullNode> nullNode = 0,
    flatbuffers::Offset<IntNode> intNode = 0,
    flatbuffers::Offset<FloatNode> floatNode = 0,
    flatbuffers::Offset<LongNode> longNode = 0,
    flatbuffers::Offset<BooleanNode> booleanNode = 0,
    flatbuffers::Offset<DoubleNode> doubleNode = 0,
    flatbuffers::Offset<StringNode> stringNode = 0,
    flatbuffers::Offset<BinaryNode> binaryNode = 0,
    flatbuffers::Offset<DecimalNode> decimalNode = 0,
    flatbuffers::Offset<InNode> inNode = 0) {
  TreeNodeBuilder builder_(_fbb);
  builder_.add_inNode(inNode);
  builder_.add_decimalNode(decimalNode);
  builder_.add_binaryNode(binaryNode);
  builder_.add_stringNode(stringNode);
  builder_.add_doubleNode(doubleNode);
  builder_.add_booleanNode(booleanNode);
  builder_.add_longNode(longNode);
  builder_.add_floatNode(floatNode);
  builder_.add_intNode(intNode);
  builder_.add_nullNode(nullNode);
  builder_.add_orNode(orNode);
  builder_.add_andNode(andNode);
  builder_.add_ifNode(ifNode);
  builder_.add_fnNode(fnNode);
  builder_.add_fieldNode(fieldNode);
  return builder_.Finish();
}

struct ExpressionRoot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOT = 4,
    VT_RESULTTYPE = 6
  };
  const TreeNode *root() const {
    return GetPointer<const TreeNode *>(VT_ROOT);
  }
  const Field *resultType() const {
    return GetPointer<const Field *>(VT_RESULTTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           VerifyOffset(verifier, VT_RESULTTYPE) &&
           verifier.VerifyTable(resultType()) &&
           verifier.EndTable();
  }
};

struct ExpressionRootBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_root(flatbuffers::Offset<TreeNode> root) {
    fbb_.AddOffset(ExpressionRoot::VT_ROOT, root);
  }
  void add_resultType(flatbuffers::Offset<Field> resultType) {
    fbb_.AddOffset(ExpressionRoot::VT_RESULTTYPE, resultType);
  }
  explicit ExpressionRootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpressionRootBuilder &operator=(const ExpressionRootBuilder &);
  flatbuffers::Offset<ExpressionRoot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpressionRoot>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpressionRoot> CreateExpressionRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TreeNode> root = 0,
    flatbuffers::Offset<Field> resultType = 0) {
  ExpressionRootBuilder builder_(_fbb);
  builder_.add_resultType(resultType);
  builder_.add_root(root);
  return builder_.Finish();
}

struct ExpressionList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPRS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ExpressionRoot>> *exprs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ExpressionRoot>> *>(VT_EXPRS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXPRS) &&
           verifier.VerifyVector(exprs()) &&
           verifier.VerifyVectorOfTables(exprs()) &&
           verifier.EndTable();
  }
};

struct ExpressionListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exprs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExpressionRoot>>> exprs) {
    fbb_.AddOffset(ExpressionList::VT_EXPRS, exprs);
  }
  explicit ExpressionListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpressionListBuilder &operator=(const ExpressionListBuilder &);
  flatbuffers::Offset<ExpressionList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpressionList>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpressionList> CreateExpressionList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExpressionRoot>>> exprs = 0) {
  ExpressionListBuilder builder_(_fbb);
  builder_.add_exprs(exprs);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExpressionList> CreateExpressionListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ExpressionRoot>> *exprs = nullptr) {
  auto exprs__ = exprs ? _fbb.CreateVector<flatbuffers::Offset<ExpressionRoot>>(*exprs) : 0;
  return gandiva::types::fbs::CreateExpressionList(
      _fbb,
      exprs__);
}

struct Condition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOT = 4
  };
  const TreeNode *root() const {
    return GetPointer<const TreeNode *>(VT_ROOT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           verifier.EndTable();
  }
};

struct ConditionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_root(flatbuffers::Offset<TreeNode> root) {
    fbb_.AddOffset(Condition::VT_ROOT, root);
  }
  explicit ConditionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConditionBuilder &operator=(const ConditionBuilder &);
  flatbuffers::Offset<Condition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Condition>(end);
    return o;
  }
};

inline flatbuffers::Offset<Condition> CreateCondition(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TreeNode> root = 0) {
  ConditionBuilder builder_(_fbb);
  builder_.add_root(root);
  return builder_.Finish();
}

struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMNS = 4
  };
  const Field *columns() const {
    return GetPointer<const Field *>(VT_COLUMNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyTable(columns()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_columns(flatbuffers::Offset<Field> columns) {
    fbb_.AddOffset(Schema::VT_COLUMNS, columns);
  }
  explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SchemaBuilder &operator=(const SchemaBuilder &);
  flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schema> CreateSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Field> columns = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_columns(columns);
  return builder_.Finish();
}

struct GandivaDataTypes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>> *dataType() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>> *>(VT_DATATYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATATYPE) &&
           verifier.VerifyVector(dataType()) &&
           verifier.VerifyVectorOfTables(dataType()) &&
           verifier.EndTable();
  }
};

struct GandivaDataTypesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>>> dataType) {
    fbb_.AddOffset(GandivaDataTypes::VT_DATATYPE, dataType);
  }
  explicit GandivaDataTypesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GandivaDataTypesBuilder &operator=(const GandivaDataTypesBuilder &);
  flatbuffers::Offset<GandivaDataTypes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GandivaDataTypes>(end);
    return o;
  }
};

inline flatbuffers::Offset<GandivaDataTypes> CreateGandivaDataTypes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>>> dataType = 0) {
  GandivaDataTypesBuilder builder_(_fbb);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

inline flatbuffers::Offset<GandivaDataTypes> CreateGandivaDataTypesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ExtGandivaType>> *dataType = nullptr) {
  auto dataType__ = dataType ? _fbb.CreateVector<flatbuffers::Offset<ExtGandivaType>>(*dataType) : 0;
  return gandiva::types::fbs::CreateGandivaDataTypes(
      _fbb,
      dataType__);
}

struct GandivaFunctions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FUNCTION = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FunctionSignature>> *function() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FunctionSignature>> *>(VT_FUNCTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FUNCTION) &&
           verifier.VerifyVector(function()) &&
           verifier.VerifyVectorOfTables(function()) &&
           verifier.EndTable();
  }
};

struct GandivaFunctionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_function(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FunctionSignature>>> function) {
    fbb_.AddOffset(GandivaFunctions::VT_FUNCTION, function);
  }
  explicit GandivaFunctionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GandivaFunctionsBuilder &operator=(const GandivaFunctionsBuilder &);
  flatbuffers::Offset<GandivaFunctions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GandivaFunctions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GandivaFunctions> CreateGandivaFunctions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FunctionSignature>>> function = 0) {
  GandivaFunctionsBuilder builder_(_fbb);
  builder_.add_function(function);
  return builder_.Finish();
}

inline flatbuffers::Offset<GandivaFunctions> CreateGandivaFunctionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FunctionSignature>> *function = nullptr) {
  auto function__ = function ? _fbb.CreateVector<flatbuffers::Offset<FunctionSignature>>(*function) : 0;
  return gandiva::types::fbs::CreateGandivaFunctions(
      _fbb,
      function__);
}

struct FunctionSignature FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_RETURNTYPE = 6,
    VT_PARAMTYPES = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const ExtGandivaType *returnType() const {
    return GetPointer<const ExtGandivaType *>(VT_RETURNTYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>> *paramTypes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>> *>(VT_PARAMTYPES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_RETURNTYPE) &&
           verifier.VerifyTable(returnType()) &&
           VerifyOffset(verifier, VT_PARAMTYPES) &&
           verifier.VerifyVector(paramTypes()) &&
           verifier.VerifyVectorOfTables(paramTypes()) &&
           verifier.EndTable();
  }
};

struct FunctionSignatureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FunctionSignature::VT_NAME, name);
  }
  void add_returnType(flatbuffers::Offset<ExtGandivaType> returnType) {
    fbb_.AddOffset(FunctionSignature::VT_RETURNTYPE, returnType);
  }
  void add_paramTypes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>>> paramTypes) {
    fbb_.AddOffset(FunctionSignature::VT_PARAMTYPES, paramTypes);
  }
  explicit FunctionSignatureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FunctionSignatureBuilder &operator=(const FunctionSignatureBuilder &);
  flatbuffers::Offset<FunctionSignature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FunctionSignature>(end);
    return o;
  }
};

inline flatbuffers::Offset<FunctionSignature> CreateFunctionSignature(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<ExtGandivaType> returnType = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ExtGandivaType>>> paramTypes = 0) {
  FunctionSignatureBuilder builder_(_fbb);
  builder_.add_paramTypes(paramTypes);
  builder_.add_returnType(returnType);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FunctionSignature> CreateFunctionSignatureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<ExtGandivaType> returnType = 0,
    const std::vector<flatbuffers::Offset<ExtGandivaType>> *paramTypes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto paramTypes__ = paramTypes ? _fbb.CreateVector<flatbuffers::Offset<ExtGandivaType>>(*paramTypes) : 0;
  return gandiva::types::fbs::CreateFunctionSignature(
      _fbb,
      name__,
      returnType,
      paramTypes__);
}

struct InNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE = 4,
    VT_INTVALUES = 6,
    VT_LONGVALUES = 8,
    VT_STRINGVALUES = 10,
    VT_BINARYVALUES = 12,
    VT_DECIMALVALUES = 14,
    VT_FLOATVALUES = 16,
    VT_DOUBLEVALUES = 18
  };
  const TreeNode *node() const {
    return GetPointer<const TreeNode *>(VT_NODE);
  }
  const IntConstants *intValues() const {
    return GetPointer<const IntConstants *>(VT_INTVALUES);
  }
  const LongConstants *longValues() const {
    return GetPointer<const LongConstants *>(VT_LONGVALUES);
  }
  const StringConstants *stringValues() const {
    return GetPointer<const StringConstants *>(VT_STRINGVALUES);
  }
  const BinaryConstants *binaryValues() const {
    return GetPointer<const BinaryConstants *>(VT_BINARYVALUES);
  }
  const DecimalConstants *decimalValues() const {
    return GetPointer<const DecimalConstants *>(VT_DECIMALVALUES);
  }
  const FloatConstants *floatValues() const {
    return GetPointer<const FloatConstants *>(VT_FLOATVALUES);
  }
  const DoubleConstants *doubleValues() const {
    return GetPointer<const DoubleConstants *>(VT_DOUBLEVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyOffset(verifier, VT_INTVALUES) &&
           verifier.VerifyTable(intValues()) &&
           VerifyOffset(verifier, VT_LONGVALUES) &&
           verifier.VerifyTable(longValues()) &&
           VerifyOffset(verifier, VT_STRINGVALUES) &&
           verifier.VerifyTable(stringValues()) &&
           VerifyOffset(verifier, VT_BINARYVALUES) &&
           verifier.VerifyTable(binaryValues()) &&
           VerifyOffset(verifier, VT_DECIMALVALUES) &&
           verifier.VerifyTable(decimalValues()) &&
           VerifyOffset(verifier, VT_FLOATVALUES) &&
           verifier.VerifyTable(floatValues()) &&
           VerifyOffset(verifier, VT_DOUBLEVALUES) &&
           verifier.VerifyTable(doubleValues()) &&
           verifier.EndTable();
  }
};

struct InNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<TreeNode> node) {
    fbb_.AddOffset(InNode::VT_NODE, node);
  }
  void add_intValues(flatbuffers::Offset<IntConstants> intValues) {
    fbb_.AddOffset(InNode::VT_INTVALUES, intValues);
  }
  void add_longValues(flatbuffers::Offset<LongConstants> longValues) {
    fbb_.AddOffset(InNode::VT_LONGVALUES, longValues);
  }
  void add_stringValues(flatbuffers::Offset<StringConstants> stringValues) {
    fbb_.AddOffset(InNode::VT_STRINGVALUES, stringValues);
  }
  void add_binaryValues(flatbuffers::Offset<BinaryConstants> binaryValues) {
    fbb_.AddOffset(InNode::VT_BINARYVALUES, binaryValues);
  }
  void add_decimalValues(flatbuffers::Offset<DecimalConstants> decimalValues) {
    fbb_.AddOffset(InNode::VT_DECIMALVALUES, decimalValues);
  }
  void add_floatValues(flatbuffers::Offset<FloatConstants> floatValues) {
    fbb_.AddOffset(InNode::VT_FLOATVALUES, floatValues);
  }
  void add_doubleValues(flatbuffers::Offset<DoubleConstants> doubleValues) {
    fbb_.AddOffset(InNode::VT_DOUBLEVALUES, doubleValues);
  }
  explicit InNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InNodeBuilder &operator=(const InNodeBuilder &);
  flatbuffers::Offset<InNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<InNode> CreateInNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TreeNode> node = 0,
    flatbuffers::Offset<IntConstants> intValues = 0,
    flatbuffers::Offset<LongConstants> longValues = 0,
    flatbuffers::Offset<StringConstants> stringValues = 0,
    flatbuffers::Offset<BinaryConstants> binaryValues = 0,
    flatbuffers::Offset<DecimalConstants> decimalValues = 0,
    flatbuffers::Offset<FloatConstants> floatValues = 0,
    flatbuffers::Offset<DoubleConstants> doubleValues = 0) {
  InNodeBuilder builder_(_fbb);
  builder_.add_doubleValues(doubleValues);
  builder_.add_floatValues(floatValues);
  builder_.add_decimalValues(decimalValues);
  builder_.add_binaryValues(binaryValues);
  builder_.add_stringValues(stringValues);
  builder_.add_longValues(longValues);
  builder_.add_intValues(intValues);
  builder_.add_node(node);
  return builder_.Finish();
}

struct IntConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<IntNode>> *intValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<IntNode>> *>(VT_INTVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTVALUES) &&
           verifier.VerifyVector(intValues()) &&
           verifier.VerifyVectorOfTables(intValues()) &&
           verifier.EndTable();
  }
};

struct IntConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_intValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IntNode>>> intValues) {
    fbb_.AddOffset(IntConstants::VT_INTVALUES, intValues);
  }
  explicit IntConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IntConstantsBuilder &operator=(const IntConstantsBuilder &);
  flatbuffers::Offset<IntConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntConstants> CreateIntConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<IntNode>>> intValues = 0) {
  IntConstantsBuilder builder_(_fbb);
  builder_.add_intValues(intValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntConstants> CreateIntConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<IntNode>> *intValues = nullptr) {
  auto intValues__ = intValues ? _fbb.CreateVector<flatbuffers::Offset<IntNode>>(*intValues) : 0;
  return gandiva::types::fbs::CreateIntConstants(
      _fbb,
      intValues__);
}

struct LongConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<LongNode>> *longValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LongNode>> *>(VT_LONGVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LONGVALUES) &&
           verifier.VerifyVector(longValues()) &&
           verifier.VerifyVectorOfTables(longValues()) &&
           verifier.EndTable();
  }
};

struct LongConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LongNode>>> longValues) {
    fbb_.AddOffset(LongConstants::VT_LONGVALUES, longValues);
  }
  explicit LongConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LongConstantsBuilder &operator=(const LongConstantsBuilder &);
  flatbuffers::Offset<LongConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LongConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<LongConstants> CreateLongConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LongNode>>> longValues = 0) {
  LongConstantsBuilder builder_(_fbb);
  builder_.add_longValues(longValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<LongConstants> CreateLongConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<LongNode>> *longValues = nullptr) {
  auto longValues__ = longValues ? _fbb.CreateVector<flatbuffers::Offset<LongNode>>(*longValues) : 0;
  return gandiva::types::fbs::CreateLongConstants(
      _fbb,
      longValues__);
}

struct DecimalConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DECIMALVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DecimalNode>> *decimalValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DecimalNode>> *>(VT_DECIMALVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DECIMALVALUES) &&
           verifier.VerifyVector(decimalValues()) &&
           verifier.VerifyVectorOfTables(decimalValues()) &&
           verifier.EndTable();
  }
};

struct DecimalConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_decimalValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DecimalNode>>> decimalValues) {
    fbb_.AddOffset(DecimalConstants::VT_DECIMALVALUES, decimalValues);
  }
  explicit DecimalConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DecimalConstantsBuilder &operator=(const DecimalConstantsBuilder &);
  flatbuffers::Offset<DecimalConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DecimalConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<DecimalConstants> CreateDecimalConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DecimalNode>>> decimalValues = 0) {
  DecimalConstantsBuilder builder_(_fbb);
  builder_.add_decimalValues(decimalValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<DecimalConstants> CreateDecimalConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DecimalNode>> *decimalValues = nullptr) {
  auto decimalValues__ = decimalValues ? _fbb.CreateVector<flatbuffers::Offset<DecimalNode>>(*decimalValues) : 0;
  return gandiva::types::fbs::CreateDecimalConstants(
      _fbb,
      decimalValues__);
}

struct FloatConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLOATVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<FloatNode>> *floatValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FloatNode>> *>(VT_FLOATVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FLOATVALUES) &&
           verifier.VerifyVector(floatValues()) &&
           verifier.VerifyVectorOfTables(floatValues()) &&
           verifier.EndTable();
  }
};

struct FloatConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_floatValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FloatNode>>> floatValues) {
    fbb_.AddOffset(FloatConstants::VT_FLOATVALUES, floatValues);
  }
  explicit FloatConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloatConstantsBuilder &operator=(const FloatConstantsBuilder &);
  flatbuffers::Offset<FloatConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloatConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloatConstants> CreateFloatConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FloatNode>>> floatValues = 0) {
  FloatConstantsBuilder builder_(_fbb);
  builder_.add_floatValues(floatValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<FloatConstants> CreateFloatConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<FloatNode>> *floatValues = nullptr) {
  auto floatValues__ = floatValues ? _fbb.CreateVector<flatbuffers::Offset<FloatNode>>(*floatValues) : 0;
  return gandiva::types::fbs::CreateFloatConstants(
      _fbb,
      floatValues__);
}

struct DoubleConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DOUBLEVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DoubleNode>> *doubleValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DoubleNode>> *>(VT_DOUBLEVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DOUBLEVALUES) &&
           verifier.VerifyVector(doubleValues()) &&
           verifier.VerifyVectorOfTables(doubleValues()) &&
           verifier.EndTable();
  }
};

struct DoubleConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_doubleValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DoubleNode>>> doubleValues) {
    fbb_.AddOffset(DoubleConstants::VT_DOUBLEVALUES, doubleValues);
  }
  explicit DoubleConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DoubleConstantsBuilder &operator=(const DoubleConstantsBuilder &);
  flatbuffers::Offset<DoubleConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleConstants> CreateDoubleConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DoubleNode>>> doubleValues = 0) {
  DoubleConstantsBuilder builder_(_fbb);
  builder_.add_doubleValues(doubleValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleConstants> CreateDoubleConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DoubleNode>> *doubleValues = nullptr) {
  auto doubleValues__ = doubleValues ? _fbb.CreateVector<flatbuffers::Offset<DoubleNode>>(*doubleValues) : 0;
  return gandiva::types::fbs::CreateDoubleConstants(
      _fbb,
      doubleValues__);
}

struct StringConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRINGVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<StringNode>> *stringValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<StringNode>> *>(VT_STRINGVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRINGVALUES) &&
           verifier.VerifyVector(stringValues()) &&
           verifier.VerifyVectorOfTables(stringValues()) &&
           verifier.EndTable();
  }
};

struct StringConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stringValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringNode>>> stringValues) {
    fbb_.AddOffset(StringConstants::VT_STRINGVALUES, stringValues);
  }
  explicit StringConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StringConstantsBuilder &operator=(const StringConstantsBuilder &);
  flatbuffers::Offset<StringConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StringConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<StringConstants> CreateStringConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<StringNode>>> stringValues = 0) {
  StringConstantsBuilder builder_(_fbb);
  builder_.add_stringValues(stringValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<StringConstants> CreateStringConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<StringNode>> *stringValues = nullptr) {
  auto stringValues__ = stringValues ? _fbb.CreateVector<flatbuffers::Offset<StringNode>>(*stringValues) : 0;
  return gandiva::types::fbs::CreateStringConstants(
      _fbb,
      stringValues__);
}

struct BinaryConstants FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BINARYVALUES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BinaryNode>> *binaryValues() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BinaryNode>> *>(VT_BINARYVALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BINARYVALUES) &&
           verifier.VerifyVector(binaryValues()) &&
           verifier.VerifyVectorOfTables(binaryValues()) &&
           verifier.EndTable();
  }
};

struct BinaryConstantsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_binaryValues(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BinaryNode>>> binaryValues) {
    fbb_.AddOffset(BinaryConstants::VT_BINARYVALUES, binaryValues);
  }
  explicit BinaryConstantsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryConstantsBuilder &operator=(const BinaryConstantsBuilder &);
  flatbuffers::Offset<BinaryConstants> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryConstants>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryConstants> CreateBinaryConstants(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BinaryNode>>> binaryValues = 0) {
  BinaryConstantsBuilder builder_(_fbb);
  builder_.add_binaryValues(binaryValues);
  return builder_.Finish();
}

inline flatbuffers::Offset<BinaryConstants> CreateBinaryConstantsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BinaryNode>> *binaryValues = nullptr) {
  auto binaryValues__ = binaryValues ? _fbb.CreateVector<flatbuffers::Offset<BinaryNode>>(*binaryValues) : 0;
  return gandiva::types::fbs::CreateBinaryConstants(
      _fbb,
      binaryValues__);
}

}  // namespace fbs
}  // namespace types
}  // namespace gandiva

#endif  // FLATBUFFERS_GENERATED_GANDIVATYPES_GANDIVA_TYPES_FBS_H_
